* Tic-tac-toe program.
* Written by Marcel Goh from 3 to ? July 2019

* CONSTANTS AND ADDRESSES:
TERM    EQU     19
BOARD   EQU     0
INBUF   EQU     100
OUTBUF1 EQU     115
OUTBUF2 EQU     130
NAME    EQU     145

* DATA:
        ORIG    200
NAMEMSG ALF     "ENTER"
        ALF     " YOUR"
        ALF     " NAME"
        ORIG    215
SIZEMSG ALF     "ENTER"
        ALF     " SIZE"
        ALF     " OF B"
        ALF     "OARD "
        ALF     "(MIN "
        ALF     "3, MA"
        ALF     "X 9) "
        ORIG    230
BADIN   ALF     "BAD I"
        ALF     "NPUT."
        ORIG    245
ERRMSG1 ALF     "ERROR"
        ALF     " PRIN"
        ALF     "ING B"
        ALF     "OARD."
        ORIG    260
RANDMSG ALF     "ENTER"
        ALF     " SEED"
        ALF     " FOR "
        ALF     "RANDO"
        ALF     "MISAT"
        ALF     "ION ("
        ALF     "0 TO "
        ALF     "9)   "
        ORIG    275
ROWMSG  ALF     "ENTER"
        ALF     " ROW "
        ALF     "(0 TO"
ROW1    ALF     " @)  "
        ORIG    290
COLMSG  ALF     "ENTER"
        ALF     " COLU"
        ALF     "MN (0"
COL1    ALF     " TO @"
        ALF     ")    "
        ORIG    305
ADVRSRY ALF     "ADVER"
        ALF     "SARY:"
        ORIG    320
ADVRMSG ALF     "THE A"
        ALF     "DVERS"
        ALF     "ARY M"
        ALF     "ADE H"
        ALF     "IS MO"
        ALF     "VE.  "
        ORIG    335
WINMSG  ALF     "YOU W"
        ALF     "IN :)"
        ORIG    350
LOSEMSG ALF     "YOU L"
        ALF     "OSE. "
        ORIG    365
TIEMSG  ALF     "IT'S "
        ALF     "A TIE"
        ALF     ".    "
        ORIG    380
XRAND   CON     0               Used to generate random sequences.
ARAND   CON     101
CRAND   CON     78903297
RANDMAX CON     0
DIM     CON     0               Dimension of board
TRNSLFT CON     0               Count down number of turns left
ROW     CON     0               Input row
COL     CON     0               Input column
NAMELEN CON     0               Length of player's name
HORDIV  ALF     "-+   "         Used to print to terminal.
BCELL   ALF     " :   "
XCELL   ALF     "X:   "
OCELL   ALF     "O:   "
TEMP    CON     0

* CODE:
        ORIG    3000
* Print various error messages.
BADPRNT OUT     ERRMSG1(TERM)
        HLT
* The three possible end-states.
TIE     OUT     TIEMSG(TERM)    It's a tie.
        HLT
BINGO   OUT     WINMSG(TERM)    Player wins.
        HLT
DARNIT  OUT     LOSEMSG(TERM)   Adversary wins.
        HLT

* Calling sequence: JMP CLRBUF
*                   NOP BUFPTR
* Entry conditions: BUFPTR points to a 15-word buffer.
* Exit conditions: The buffer is cleared to 0, rI1, rI2 affected.
CLRBUF  STJ     9F
        STJ     *+1
        LD1     *(0:2)          rI1 <- STRPTR.
        ENT2    15
1H      STZ     0,1             Loop 15 times and clear each word.
        INC1    1
        DEC2    1
        J2P     1B
9H      JMP     *               Return to caller.

* Calling sequence: JMP RANDM
* Entry conditions: Location XRAND contains integer X.
* Exit conditions: X <- rA <- (aX + c) mod w, rX <- 0, overflow off.
RANDM   STJ     9F
        LDA     ARAND
        MUL     XRAND
        SLAX    5               rA <- rAX mod w.
        ADD     CRAND           rA <- rA + c. (Overflow may be on.)
        STA     XRAND           Update XRAND.
        JOV     *+1             Toggle overflow if on.
9H      JMP     *               Return to caller.

* Calling sequence: JMP RANDCEL
* Entry conditions: Location DIM contains dimension.
*                   Location RANDMAX contains DIM * floor(WORDSIZE/DIM)
* Exit conditions: rX holds a random integer from 0 to DIM - 1.
*                  rA also affected.
RANDCEL STJ     9F
1H      JMP     RANDM           Store a new pseudo-random number in rA.
        CMPA    RANDMAX
        JGE     1B              Throw away result and try again if too large.
        SRAX    5               Otherwise,
        DIV     DIM                 rX holds a random integer from 0 to DIM - 1.
9H      JMP     *               Return to caller.

* Calling sequence: JMP STRLEN
*                   NOP STRPTR
* Entry conditions: STRPTR points to string
* Exit conditions: rI2 is number of consecutive leading non-zero characters,
*                  rX, rI1 also affected.
STRLEN  STJ     9F
        STJ     *+1
        LD1     *(0:2)          rI1 <- STRPTR.
        ENT2    0               Initialise rI2 to 0.
1H      LDX     0,1(1:1)        Check if each of five letters in word
        JXZ     9F                  is non-zero, exit loop at first zero
        INC2    1                   found.
        LDX     0,1(2:2)
        JXZ     9F
        INC2    1
        LDX     0,1(3:3)
        JXZ     9F
        INC2    1
        LDX     0,1(4:4)
        JXZ     9F
        INC2    1
        LDX     0,1(5:5)
        JXZ     9F
        INC2    1
        INC1    1               Increment string pointer and loop.
        JMP     1B
9H      JMP     *               Return to caller.

* Calling sequence: JMP INSCHR
*                   NOP STRPTR
*                   NOP CHARS
* Entry conditions: STRPTR points to string, CHARS(2:2) a char to add,
*                   rX a 0-index.
* Exit conditions:  STRPTR[rX] <- CHARS(2:2), TEMP affected.
*                   rA, rI1, rI2 affected.
INSCHR  STJ     9F
        STJ     *+1
        ENT1    *               rI1 points to "NOP STRPTR" cell.
        LD2     1,1(0:2)        rI2 <- CHARS.
        LD2     0,2(2:2)        rI2 <- CHARS(2:2).
        LD1     0,1(0:2)        rI1 <- STRPTR.
        ENTA    0
        DIV     =5=             rA <- rX / 5, rX <- rX mod 5.
        ST1     TEMP
        ADD     TEMP            rA <- rA + rI1.
        STA     TEMP
        LD1     TEMP            rI1 <- rA.
* Case-match on rX:
        CMPX    =0=             Case rX = 0.
        JNE     1F
        ST2     0,1(1:1)
        JMP     9F
1H      CMPX    =1=             Case rX = 1.
        JNE     1F
        ST2     0,1(2:2)
        JMP     9F
1H      CMPX    =2=             Case rX = 2.
        JNE     1F
        ST2     0,1(3:3)
        JMP     9F
1H      CMPX    =3=             Case rX = 3.
        JNE     1F
        ST2     0,1(4:4)
        JMP     9F
1H      ST2     0,1(5:5)   Case rX = 4.
9H      JMP     *               Return to caller.

* Calling sequence: JMP PTWOCHR
*                   NOP CHARS
* Entry conditions: rI1 points to a word in buffer,
*                   rI2 (in the range 1-5) indicates where to add chars,
*                   CHARS(1:1) and CHARS(2:2) are the two chars to print.
* Exit conditions: rI2 incremented by 2 (cycling in the range 1-5);
*                  if rI2 holds 4 or 5, then rI1 increments by 1;
*                  rI3, rI4 also affected.
PTWOCHR STJ     9F
        STJ     *+1
        LD3     *(0:2)          rI3 <- CHARS.
        LD4     0,3(2:2)        rI4 <- second char to print.
        LD3     0,3(1:1)        rI3 <- first char to print.
* Case-match on rI2:
        CMP2    =1=             Case rI2 = 1.
        JNE     1F
        ST3     0,1(1:1)
        ST4     0,1(2:2)
        JMP     8F
1H      CMP2    =2=             Case rI2 = 2.
        JNE     1F
        ST3     0,1(2:2)
        ST4     0,1(3:3)
        JMP     8F
1H      CMP2    =3=             Case rI2 = 3.
        JNE     1F
        ST3     0,1(3:3)
        ST4     0,1(4:4)
        JMP     8F
1H      CMP2    =4=             Case rI2 = 4.
        JNE     1F
        ST3     0,1(4:4)
        ST4     0,1(5:5)
        INC1    1               Increment rI1 by one.
        DEC2    5               rI2 <- -1 (for cycle).
        JMP     8F
1H      CMP2    =5=             Case rI2 = 5.
        JNE     1F
        ST3     0,1(5:5)
        INC1    1               Increment rI1 by one.
        DEC2    5               rI2 <- 0 (for cycle).
        ST4     0,1(1:1)        (In the next memory cell.)
        JMP     8F
1H      JMP     BADPRNT         No case matched.
8H      INC2    2               rI2 <- rI2 + 2.
9H      JMP     *               Return to caller.

* Calling sequence: JMP PBORDER
* Entry conditions: Location DIM contains dimension of board,
*                   location HORDIV contains "-+   ".
* Exit conditions: Horizontal divider printed to screen.
*                  OUTBUF1 affected.
*                  Registers affected: rA, rI1, rI2, rI3, rI4.
PBORDER STJ     9F
        JMP     CLRBUF          Clear OUTBUF1.
        NOP     OUTBUF1
        ENT2    44              rI2 <- '+'.
        ST2     OUTBUF1(1:1)    Add '+' to first block of buffer.
        ENT1    OUTBUF1         rI1 points to first block of buffer.
        ENT2    2               rI2 <- 2.
        LDA     DIM             rA <- *DIM.
1H      JMP     PTWOCHR         Do:
        NOP     HORDIV              Add "-+" to buffer.
        DECA    1
        JANZ    1B              While rA > 0.
        OUT     OUTBUF1(TERM)   Print the buffer to terminal.
9H      JMP     *               Return to caller.

* Calling sequence: JMP PBOARD
* Entry conditions: BOARD contains board of dimension DIM.
* Exit conditions: Board printed to terminal, OUTBUF1 affected.
*                  All registers used.
PBOARD  STJ     9F
* Print top border
        JMP     PBORDER         Print top border.
        LDX     DIM             rX <- *DIM.
        ENT5    BOARD           rI5 is the board pointer.
1H      JMP     CLRBUF          Do:
        NOP     OUTBUF1             Clear buffer.
        ENT1    54
        ST1     OUTBUF1(1:1)        Add ':' to buffer.
        ENT1    OUTBUF1             rI1 <- OUTBUF.
        ENT2    2                   rI2 <- 2.
        LD6     DIM                 Set rI6 <- *DIM.
2H      DEC6    1                   Do: decrement rI6 by one.
        LDA     0,5                     rA <- next value of array.
        INC5    1                       Increment rI5 by one.
        JAP     4F                      Branch on sign of rA.
        JAN     3F
        JMP     PTWOCHR                 If rA = 0, then
        NOP     BCELL                       Add blank cell to buffer.
        JMP     5F
3H      JMP     PTWOCHR                 If rA is negative, then
        NOP     OCELL                       Add "O"-cell to buffer.
        JMP     5F
4H      JMP     PTWOCHR                 If rA is positive, then
        NOP     XCELL                       Add "X"-cell to buffer.
5H      J6P     2B                  While rI6 > 0.
        OUT     OUTBUF1(TERM)       Output buffer to terminal.
        JMP     PBORDER             Print a horizontal border.
        DECX    1                   Decrement rX by one.
        JXP     1B              While rX > 0.
9H      JMP     *               Return to caller.

* Calling sequence: JMP GETNUM
*                   NOP ERRJMP
* Entry conditions: None
* Exit conditions: If input is invalid, exit is made to ERRJMP
*                  rA holds 1-digit number input by user (0 to 9).
*                  rX, rI1, rI2, rI3, TEMP memory cell also affected
GETNUM  STJ     9F
        STJ     *+1
        LD3     *(0:2)          rI3 <- ERRJMP.
        JMP     CLRBUF          Clear input buffer.
        NOP     INBUF
        IN      INBUF(TERM)
        ENTX    0
        LDX     INBUF(2:5)
        JXZ     1F              Ensure input has at most one digit.
        OUT     BADIN(TERM)         If not then try again.
        JMP     0,3
1H      LDA     INBUF
        JANZ    2F              Ensure input has at least one digit.
        OUT     BADIN(TERM)         If not then try again.
        JMP     0,3
2H      SRAX    9
        NUM     
9H      JMP     *               Return to caller.

* Calling sequence: JMP ROWSUM
* Entry conditions: rI4 holds 0-index indicating row of BOARD of dimension DIM.
* Exit conditions: rA holds sum of row. rX, rI1, rI2, TEMP also affected.
*                  If there are empty cells, rI5 is index of last one found.
ROWSUM  STJ     9F
        ENTA    0,4             rA <- rI4.
        MUL     DIM             rX <- rA * DIM.
        STX     TEMP
        LD1     TEMP            rI1 <- rX.
        LD2     DIM             rI2 <- *DIM.
        ENTA    0               rA <- 0.
1H      ADD     BOARD,1         Do: rA <- rA + BOARD[rI1].
        LDX     BOARD,1
        JXNZ    2F                  If cell is empty,
        ENT5    0,1                     rI5 <- rI1.
2H      DEC2    1                   Decrement rI2 by one.
        INC1    1                   Increment rI1 by one.
        J2P     1B              While rI2 > 0.
9H      JMP     *               Return to caller.

* Calling sequence: JMP COLSUM
* Entry conditions: rI4 holds 0-index indicating row of BOARD of dimension DIM.
* Exit conditions: rA holds sum of row. rX, rI1, rI2, rI3 also affected.
*                  If there are empty cells, rI5 is index of last one found.
COLSUM  STJ     9F
        ENT1    0,4
        LD2     DIM             rI2 <- *DIM.
        LD3     DIM             rI3 <- *DIM.
        ENTA    0               rA <- 0.
1H      ADD     BOARD,1         Do: rA <- rA + BOARD[rI1].
        LDX     BOARD,1
        JXNZ    2F                  If cell is empty,
        ENT5    0,1                     rI5 <- rI1.
2H      DEC2    1                   Decrement rI2 by one.
        INC1    0,3                 Increment rI1 by *DIM.
        J2P     1B              While rI2 > 0.
9H      JMP     *               Return to caller.

* Calling sequence: JMP DIAGSUM
* Entry conditions: BOARD is start pointer of board of dimension DIM.
*                   rI4 an integer.
* Exit conditions: If rI4 negative, rA holds sum of NW to SE diagonal.
*                  Otherwise, rA holds sum of NE to SW diagonal.
*                  If there are empty cells, rI5 is index of last one found.
*                  rX, rI1, rI2, rI3, TEMP also affected.
DIAGSUM STJ     9F
        LDA     DIM             rA <- *DIM.
        J4N     1F
        DECA    1               If rI4 non-negative:
        STA     TEMP
        LD3     TEMP                rI3 <- *DIM - 1.
        ENT1    0,3                 rI1 starts at top right of board.
        JMP     2F
1H      INCA    1               If rI4 negative:
        STA     TEMP
        LD3     TEMP                rI3 <- *DIM + 1.
        ENT1    0                   rI1 starts at top left of board.
2H      LD2     DIM             rI2 <- *DIM.
        ENTA    0               rA <- 0.
1H      ADD     BOARD,1         Do: rA <- rA + BOARD[rI1].
        LDX     BOARD,1
        JXNZ    2F                  If cell is empty,
        ENT5    0,1                     rI5 <- rI1.
2H      DEC2    1                   Decrement rI2 by one.
        INC1    0,3                 rI1 <- rI1 + rI3.
        J2P     1B              While rI2 > 0.
9H      JMP     *               Return to caller.

* Calling sequence: JMP GETPLYR
* Entry conditions: BOARD points to a square board of dimension DIM,
*                   with at least one empty cell.
* Exit conditions: Cell of player's choice is filled with an "X".
*                  TRNSLFT decrements by 1.
*                  Registers used: rA, rX, rI1, rI2, rI3.
*                  Memory cells used: ROW, COL, DIM, TEMP.
GETPLYR STJ     9F
        OUT     NAME(TERM)      Print player's name.
        JBUS    *(TERM)
1H      OUT     COLMSG(TERM)
        JMP     GETNUM          rA <- 1-digit number from user.
        NOP     1B
        CMPA    DIM
        JL      2F              If rA >= DIM, then
7H      OUT     BADIN(TERM)         print error message and try again.
        JMP     1B
2H      STA     COL             Save column.
1H      OUT     ROWMSG(TERM)
        JMP     GETNUM
        NOP     1B
        CMPA    DIM
        JL      2F              Again, ensure rA < DIM.
        OUT     BADIN(TERM)
        JMP     1B
2H      MUL     DIM             rAX <- DIM * ROW.
        SLAX    5               rA <- rAX.
        ADD     COL             rA <- rA + COL (the offset).
        STA     TEMP
        LD1     TEMP            rI1 <- rA (the correct cell).
        LD3     BOARD,1
        J3NZ    7B              If the cell is not blank, try again.
        ENT2    1               Otherwise ...
        ST2     BOARD,1             ... set *(BOARD + offset) <- 1.
        LDA     TRNSLFT         Decrement TRNSLFT.
        DECA    1
        STA     TRNSLFT
9H      JMP     *               Return to caller.

* Calling sequence: JMP CHKWINR
* Entry conditions: BOARD points to board of dimension DIM.
* Exit conditions: Jumps to BINGO if player wins; DARNIT if adversary wins;
*                  TIE if board is full; returns to caller otherwise.
*                  Registers used, rA, rX, rI1 through rI4.
* GAMEOVR gets called if all entries in a row/column/diagonal are the same,
* i.e. the sum is *DIM or -*DIM.
ABS     EQU     1:5             Absolute value
GAMEOVR JAN     DARNIT          Someone won: branch on sign of rA.
        JMP     BINGO
CHKWINR STJ     9F
        LD4     DIM
        DEC4    1               rI4 <- *DIM - 1.
1H      JMP     ROWSUM          Do: rA is sum of rI4-th row.
        CMPA    DIM(ABS)            If abs(rA) = *DIM, someone won.
        JNE     2F
        JMP     GAMEOVR
2H      JMP     COLSUM              rA is sum of rI4-th column.
        CMPA    DIM(ABS)            If abs(rA) = *DIM, someone won.
        JNE     2F
        JMP     GAMEOVR
2H      DEC4    1                   Decrement rI4 by one.
        J4NN    1B              While rI4 >= 0.
        JMP     DIAGSUM         Sum first diagonal (rI4 is negative here).
        CMPA    DIM(ABS)        Check if someone won.
        JNE     2F
        JMP     GAMEOVR
2H      ENT4    1               rI4 is positive.
        JMP     DIAGSUM         Sum second diagonal.
        CMPA    DIM(ABS)        Check if someone won.
        JNE     2F
        JMP     GAMEOVR
2H      LDA     TRNSLFT
        JAZ     TIE             If *TRNSLFT = 0, it's a tie.
9H      JMP     *               Return to caller.

* Main entry point
MAIN    OUT     NAMEMSG(TERM)
        IN      NAME(TERM)
        LDA     NAME            Use first five letters of player's name
        JANZ    1F                  as initial seed for RAND, unless zero.
        OUT     BADIN(TERM)
        JMP     MAIN            If input bad, try again.
1H      STA     XRAND
        JMP     STRLEN          rI2 <- length of NAME.
        NOP     NAME
        ST2     NAMELEN         *NAMELEN <- rI2.
        NOP     NAME
        ST2     TEMP
1H      JMP     RANDM           Call RANDM once for every letter in
        DEC2    1                   player's name.
        J2P     1B
1H      OUT     RANDMSG(TERM)
        JMP     GETNUM
        NOP     1B
        STA     TEMP
        LD2     TEMP            rI2 <- 1-digit number from user.
1H      J2NP    2F
        JMP     RANDM           Call RANDM rI2 times.
        DEC2    1
        JMP     1B
2H      OUT     SIZEMSG(TERM)   Ask user for dimension size.
        JMP     GETNUM          rA <- 1-digit number from user.
        NOP     2B
        CMPA    =3=             Ensure input is between 3 and 9, inclusive:
        JGE     3F
        OUT     BADIN(TERM)         If input < 3, print message ...
        JMP     2B                  ... and try again.
3H      CMPA    =9=
        JLE     4F
        OUT     BADIN(TERM)         If input > 9, print message ...
        JMP     2B                  ... and try again.
4H      STA     DIM             DIM <- rA, the dimension of the board.
        ADD     =29=            (Decrement rA by one, then convert to char.)
        STA     ROW1(2:2)       Enter correct bound into ROWMSG.
        STA     COL1(5:5)       Enter correct bound into COLMSG.
        ENTX    1
        SLAX    5               rAX <- word size.
        DIV     DIM             rA <- floor(WORDSIZE / DIM)
        STA     RANDMAX
        LDA     DIM
        MUL     DIM             rX <- DIM * DIM.
        STX     TRNSLFT         *TRNSLFT <- rX.
        LDX     NAMELEN
        JMP     INSCHR
        NOP     NAME
        NOP     BCELL           Append a ':' to the end of NAME.
LOOP    JMP     GETPLYR
        JMP     PBOARD          
        JMP     CHKWINR         Check if someone won.
        JMP     LOOP
        END     MAIN
