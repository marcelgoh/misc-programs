* Tic-tac-toe program

* CONSTANTS AND ADDRESSES:
TERM    EQU     19
BOARD   EQU     0
INBUF   EQU     100
OUTBUF1 EQU     115
OUTBUF2 EQU     130
NAME    EQU     145

* DATA:
        ORIG    200
NAMEMSG ALF     "ENTER"
        ALF     " YOUR"
        ALF     " NAME"
        ORIG    215
SIZEMSG ALF     "ENTER"
        ALF     " SIZE"
        ALF     " OF B"
        ALF     "OARD "
        ALF     "(MIN "
        ALF     "3, MA"
        ALF     "X 9) "
        ORIG    230
ERRMSG1 ALF     "BAD I"
        ALF     "NPUT,"
        ALF     " PROG"
        ALF     "RAM H"
        ALF     "ALTED"
        ALF     ".    "
        ORIG    245
ERRMSG2 ALF     "ERROR"
        ALF     " PRIN"
        ALF     "ING B"
        ALF     "OARD."
        ORIG    260
RANDMSG ALF     "ENTER"
        ALF     " SEED"
        ALF     " FOR "
        ALF     "RANDO"
        ALF     "MISAT"
        ALF     "ION ("
        ALF     "0 TO "
        ALF     "9)   "
        ORIG    275
XRAND   CON     0               Used to generate random sequences.
ARAND   CON     101
CRAND   CON     78903297
DIM     CON     0               Dimension of board
HORDIV  ALF     "-+   "         Used to print to terminal.
BCELL   ALF     " :   "
XCELL   ALF     "X:   "
OCELL   ALF     "O:   "
        CON     0
TEMP    CON     0

* CODE:
        ORIG    3000
* Print various error messages.
BADIN   OUT     ERRMSG1(TERM)
        HLT
BADPRNT OUT     ERRMSG2(TERM)
        HLT

* Calling sequence: JMP CLRBUF
*                   NOP BUFPTR
* Entry conditions: BUFPTR points to a 15-word buffer.
* Exit conditions: The buffer is cleared to 0, rI1, rI2 affected.
CLRBUF  STJ     9F
        STJ     *+1
        LD1     *(0:2)          rI1 <- STRPTR.
        ENT2    15
1H      STZ     0,1             Loop 15 times and clear each word.
        INC1    1
        DEC2    1
        J2P     1B
9H      JMP     *               Return to caller.

* Calling sequence: JMP RANDM
* Entry conditions: Location XRAND contains integer X.
* Exit conditions: X <- rA <- (aX + c) mod w, rX <- 0, overflow off.
RANDM   STJ     9F
        LDA     ARAND
        MUL     XRAND
        SLAX    5               rA <- rAX mod w.
        ADD     CRAND           rA <- rA + c. (Overflow may be on.)
        STA     XRAND           Update XRAND.
        JOV     *+1             Toggle overflow if on.
9H      JMP     *               Return to caller.

* Calling sequence: JMP STRLEN
*                   NOP STRPTR
* Entry conditions: STRPTR points to string
* Exit conditions: rI2 is number of consecutive leading non-zero characters,
*                  rX, rI1 also affected.
STRLEN  STJ     9F
        STJ     *+1
        LD1     *(0:2)          rI1 <- STRPTR.
        ENT2    0               Initialise rI2 to 0.
1H      LDX     0,1(1:1)        Check if each of five letters in word
        JXZ     9F                  is non-zero, exit loop at first zero
        INC2    1                   found.
        LDX     0,1(2:2)
        JXZ     9F
        INC2    1
        LDX     0,1(3:3)
        JXZ     9F
        INC2    1
        LDX     0,1(4:4)
        JXZ     9F
        INC2    1
        LDX     0,1(5:5)
        JXZ     9F
        INC2    1
        INC1    1               Increment string pointer and loop.
        JMP     1B
9H      JMP     *               Return to caller.

* Calling sequence: JMP PTWOCHR
*                   NOP CHARS
* Entry conditions: rI1 points to a word in buffer,
*                   rI2 (in the range 1-5) indicates where to add chars,
*                   CHARS(1:1) and CHARS(2:2) are the two chars to print.
* Exit conditions: rI2 incremented by 2 (cycling in the range 1-5);
*                  if rI2 holds 4 or 5, then rI1 increments by 1;
*                  rI3, rI4 also affected.
PTWOCHR STJ     9F
        STJ     *+1
        LD3     *(0:2)          rI3 <- CHARS.
        LD4     0,3(2:2)        rI4 <- second char to print.
        LD3     0,3(1:1)        rI3 <- first char to print.
* Case-match on rI2:
        CMP2    =1=             Case rI2 = 1.
        JNE     1F
        ST3     0,1(1:1)
        ST4     0,1(2:2)
        JMP     8F
1H      CMP2    =2=             Case rI2 = 2.
        JNE     1F
        ST3     0,1(2:2)
        ST4     0,1(3:3)
        JMP     8F
1H      CMP2    =3=             Case rI2 = 3.
        JNE     1F
        ST3     0,1(3:3)
        ST4     0,1(4:4)
        JMP     8F
1H      CMP2    =4=             Case rI2 = 4.
        JNE     1F
        ST3     0,1(4:4)
        ST4     0,1(5:5)
        INC1    1               Increment rI1 by one.
        DEC2    5               rI2 <- -1 (for cycle).
        JMP     8F
1H      CMP2    =5=             Case rI2 = 5.
        JNE     1F
        ST3     0,1(5:5)
        INC1    1               Increment rI1 by one.
        DEC2    5               rI2 <- 0 (for cycle).
        ST4     0,1(1:1)        (In the next memory cell.)
        JMP     8F
1H      JMP     BADPRNT         No case matched.
8H      INC2    2               rI2 <- rI2 + 2.
9H      JMP     *               Return to caller.

* Calling sequence: JMP PBORDER
* Entry conditions: Location DIM contains dimension of board,
*                   location HORDIV contains "-+   ".
* Exit conditions: Horizontal divider printed to screen.
*                  OUTBUF1 affected.
*                  Registers affected: rA, rI1, rI2, rI3, rI4.
PBORDER STJ     9F
        JMP     CLRBUF          Clear OUTBUF1.
        NOP     OUTBUF1
        ENT2    44              rI2 <- '+'.
        ST2     OUTBUF1(1:1)    Add '+' to first block of buffer.
        ENT1    OUTBUF1         rI1 points to first block of buffer.
        ENT2    2               rI2 <- 2.
        LDA     DIM             rA <- *DIM.
1H      JMP     PTWOCHR         Do:
        NOP     HORDIV              Add "-+" to buffer.
        DECA    1
        JANZ    1B              While rA > 0.
        OUT     OUTBUF1(TERM)   Print the buffer to terminal.
9H      JMP     *               Return to caller.

* Calling sequence: JMP PBOARD
* Entry conditions: BOARD contains board of dimension DIM.
* Exit conditions: Board printed to terminal, OUTBUF1 affected.
*                  All registers used.
PBOARD  STJ     9F
* Print top border
        JMP     PBORDER         Print top border.
        LDX     DIM             rX <- *DIM.
        ENT5    BOARD           rI5 is the board pointer.
1H      JMP     CLRBUF          Do:
        NOP     OUTBUF1             Clear buffer.
        ENT1    54
        ST1     OUTBUF1(1:1)        Add ':' to buffer.
        ENT1    OUTBUF1             rI1 <- OUTBUF.
        ENT2    2                   rI2 <- 2.
        LD6     DIM                 Set rI6 <- *DIM.
2H      DEC6    1                   Do: decrement rI6 by one.
        LDA     0,5                     rA <- next value of array.
        INC5    1                       Increment rI5 by one.
        JAP     4F                      Branch on sign of rA.
        JAN     3F
        JMP     PTWOCHR                 If rA = 0, then
        NOP     BCELL                       Add blank cell to buffer.
        JMP     5F
3H      JMP     PTWOCHR                 If rA is negative, then
        NOP     OCELL                       Add "O"-cell to buffer.
        JMP     5F
4H      JMP     PTWOCHR                 If rA is positive, then
        NOP     XCELL                       Add "X"-cell to buffer.
5H      J6P     2B                  While rI6 > 0.
        OUT     OUTBUF1(TERM)       Output buffer to terminal.
        JMP     PBORDER             Print a horizontal border.
        DECX    1                   Decrement rX by one.
        JXP     1B              While rX > 0.
9H      JMP     *               Return to caller.

* Calling sequence: JMP GETNUM
* Entry conditions: None
* Exit conditions: rA holds 1-digit number input by user (0 to 9).
*                  rX, TEMP memory cell also affected
GETNUM  STJ     9F
        JMP     CLRBUF          Clear input buffer.
        NOP     INBUF
        IN      INBUF(TERM)
        LDA     31
        SLA     4
        STA     TEMP            TEMP contains + 31 00 00 00 00
        LDA     INBUF
        SRAX    5
        DIV     TEMP
        JXNZ    BADIN           Ensure input has at most one digit.
        LDA     INBUF
        JAZ     BADIN           Ensure input has at least one digit.
        SRAX    9
        NUM     
9H      JMP     *               Return to caller.

* Main entry point
MAIN    OUT     NAMEMSG(TERM)
        IN      NAME(TERM)
        LDA     NAME            Use first five letters of player's name
        JANZ    1F                  as initial seed for RAND, unless zero.
        JMP     BADIN
1H      STA     XRAND
        JMP     STRLEN          rI2 <- length of NAME
        NOP     NAME
        ST2     TEMP
1H      JMP     RANDM           Call RANDM once for every letter in
        DEC2    1                   player's name.
        J2P     1B
        OUT     RANDMSG(TERM)
        JMP     GETNUM
        STA     TEMP
        LD2     TEMP            rI2 <- 1-digit number from user.
1H      J2NP    2F
        JMP     RANDM           Call RANDM rI2 times.
        DEC2    1
        JMP     1B
2H      OUT     SIZEMSG(TERM)   Ask user for dimension size.
        JMP     GETNUM          rA <- 1-digit number from user.
        CMPA    =3=             Ensure input is between 3 and 9, inclusive.
        JL      BADIN
        CMPA    =9=
        JG      BADIN
        STA     DIM             DIM <- rA, the dimension of the board.
        ENT1    -1
        ENT2    1
        ST1     BOARD+4
        ST2     BOARD+5
        JMP     PBOARD
        HLT
        END     MAIN
