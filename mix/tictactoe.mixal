* Tic-tac-toe program

* CONSTANTS AND ADDRESSES:
TERM    EQU     19
BOARD   EQU     0
INBUF   EQU     100
OUTBUF1 EQU     115
OUTBUF2 EQU     130
NAME    EQU     145

* DATA:
        ORIG    200
NAMEMSG ALF     "ENTER"
        ALF     " YOUR"
        ALF     " NAME"
        ORIG    215
SIZEMSG ALF     "ENTER"
        ALF     " SIZE"
        ALF     " OF B"
        ALF     "OARD "
        ALF     "(MIN "
        ALF     "3, MA"
        ALF     "X 9) "
        ORIG    230
ERRMSG1 ALF     "BAD I"
        ALF     "NPUT,"
        ALF     " PROG"
        ALF     "RAM H"
        ALF     "ALTED"
        ALF     ".    "
        ORIG    245
ERRMSG2 ALF     "ERROR"
        ALF     " PRIN"
        ALF     "ING B"
        ALF     "OARD."
        ORIG    260
XRAND   CON     0               Used to generate random sequences.
ARAND   CON     101
CRAND   CON     78903297
DIM     CON     0               Dimension of board
BORDER3 ALF     "012  "         Labels for top border of board.
BORDER4 ALF     "0123 "
BORDER5 ALF     "01234"
HORDIV  ALF     "+++++"
        CON     0
TEMP    CON     0

* CODE:
        ORIG    3000
* Print various error messages.
BADIN   OUT     ERRMSG1(TERM)
        HLT
BADPRNT OUT     ERRMSG2(TERM)
        HLT

* Calling sequence: JMP CLRBUF
*                   NOP BUFPTR
* Entry conditions: BUFPTR points to a 15-word buffer.
* Exit conditions: The buffer is cleared to 0, rI1, rI2 affected.
CLRBUF  STJ     9F
        STJ     *+1
        LD1     *(0:2)          rI1 <- STRPTR.
        ENT2    15
1H      STZ     0,1             Loop 15 times and clear each word.
        INC1    1
        DEC2    1
        J2P     1B
9H      JMP     *               Return to caller.

* Calling sequence: JMP RANDM
* Entry conditions: Location XRAND contains integer X.
* Exit conditions: X <- rA <- (aX + c) mod w, rX <- 0, overflow off.
RANDM   STJ     9F
        LDA     ARAND
        MUL     XRAND
        SLAX    5               rA <- rAX mod w.
        ADD     CRAND           rA <- rA + c. (Overflow may be on.)
        STA     XRAND           Update XRAND.
        JOV     *+1             Toggle overflow if on.
9H      JMP     *               Return to caller.

* Calling sequence: JMP STRLEN
*                   NOP STRPTR
* Entry conditions: STRPTR points to string
* Exit conditions: rI2 is number of consecutive leading non-zero characters,
*                  rX, rI1 also affected.
STRLEN  STJ     9F
        STJ     *+1
        LD1     *(0:2)          rI1 <- STRPTR.
        ENT2    0               Initialise rI2 to 0.
1H      LDX     0,1(1:1)        Check if each of five letters in word
        JXZ     9F                  is non-zero, exit loop at first zero
        INC2    1                   found.
        LDX     0,1(2:2)
        JXZ     9F
        INC2    1
        LDX     0,1(3:3)
        JXZ     9F
        INC2    1
        LDX     0,1(4:4)
        JXZ     9F
        INC2    1
        LDX     0,1(5:5)
        JXZ     9F
        INC2    1
        INC1    1               Increment string pointer and loop.
        JMP     1B
9H      JMP     *               Return to caller.

* Calling sequence: JMP PTWOCHR
*                   NOP CHARS
* Entry conditions: rI1 points to a word in buffer,
*                   rI2 (in the range 1-5) indicates where to add chars,
*                   CHARS(1:1) and CHARS(2:2) are the two chars to print.
* Exit conditions: rI2 incremented by 2 (cycling in the range 1-5),
*                  If rI2 holds 4 or 5, then rI1 increments by 1,
*                  rI3 also affected.
PTWOCHR STJ     9F
        STJ     *+1
        LD3     *(0:2)          rI3 <- CHARS.
        LD4     0,3(2:2)        rI4 <- second char to print.
        LD3     0,3(1:1)        rI3 <- first char to print.
* Case-match on rI2:
        CMP2    =1=             Case rI2 = 1.
        JNE     1F
        ST3     0,1(1:1)
        ST4     0,1(2:2)
        JMP     8F
1H      CMP2    =2=             Case rI2 = 2.
        JNE     1F
        ST3     0,1(2:2)
        ST4     0,1(3:3)
        JMP     8F
1H      CMP2    =3=             Case rI2 = 3.
        JNE     1F
        ST3     0,1(3:3)
        ST4     0,1(4:4)
        JMP     8F
1H      CMP2    =4=             Case rI2 = 4.
        JNE     1F
        ST3     0,1(4:4)
        ST4     0,1(5:5)
        INC1    1               Increment rI1 by one.
        DEC2    5               rI2 <- -1 (for cycle).
        JMP     8F
1H      CMP2    =5=             Case rI2 = 5.
        JNE     1F
        ST3     0,1(5:5)
        INC1    1               Increment rI1 by one.
        DEC2    5               rI2 <- 0 (for cycle).
        ST4     0,1(1:1)        (In the next memory cell.)
        JMP     8F
1H      JMP     BADPRNT         No case matched.
8H      INC2    2               rI2 <- rI2 + 2.
9H      JMP     *               Return to caller.

* Calling sequence: JMP PBOARD
* Entry conditions: BOARD contains board of dimension DIM.
* Exit conditions: Board printed to terminal, OUTBUF1, TEMP affected.
*                  Registers used: rA, rX, rI2, rI3.
PBOARD  STJ     9F
* Print top border
        JMP     CLRBUF          Clear OUTBUF1.
        NOP     OUTBUF1
        ENT2    44              rI2 <- '+'.
        ST2     OUTBUF1(5:5)    First block is "    +"
        LDA     DIM             rA <- DIM.
        CMPA    =5=             Check for cases of first block.
        JGE     2F
        CMPA    =3=
        JNE     3F
        LDX     BORDER3         Case DIM = 3:
        STX     OUTBUF1+1           First block is "012  " and
        JMP     8F                  no second block.
3H      LDX     BORDER4         Case DIM = 4:
        STX     OUTBUF1+1           First block is "0123 " and
        JMP     8F                  no second block.
2H      LDX     BORDER5         If DIM >= 5:
        STX     OUTBUF1+1           First block is "01234".
        LD2     DIM             If DIM = 5:
        DEC2    5
        J2Z     8F                  Jump to print, no need for second block.
        STZ     TEMP            Clear TEMP memory.
        ENT3    35              r3 <- '5'.
        ST3     TEMP(1:1)       Append '5' to TEMP.
        DEC2    1
        J2Z     7F              Jump if DIM = 6.
        INC3    1
        ST3     TEMP(2:2)       Append '6' to TEMP.
        DEC2    1
        J2Z     7F              Jump if DIM = 7.
        INC3    1
        ST3     TEMP(3:3)       Append '7' to TEMP.
        DEC2    1
        J2Z     7F              Jump if DIM = 8.
        INC3    1
        ST3     TEMP(4:4)       Append '8' to TEMP.
7H      LDX     TEMP
        STX     OUTBUF1+2       Add second block to buffer.
8H      OUT     OUTBUF1(TERM)   Print buffer.
* Print horizontal divider
        LDX     HORDIV
        STX     OUTBUF1
        STX     OUTBUF1+1
        STX     OUTBUF1+2
        OUT     OUTBUF1(TERM)
9H      JMP     *               Return to caller.

* Calling sequence: JMP GETNUM
* Entry conditions: None
* Exit conditions: rA holds 1-digit number input by user (0 to 9).
*                  rX, TEMP memory cell also affected
GETNUM  STJ     9F
        JMP     CLRBUF          Clear input buffer.
        NOP     INBUF
        IN      INBUF(TERM)
        LDA     31
        SLA     4
        STA     TEMP            TEMP contains + 31 00 00 00 00
        LDA     INBUF
        SRAX    5
        DIV     TEMP
        JXNZ    BADIN           Ensure input has at most one digit.
        LDA     INBUF
        JAZ     BADIN           Ensure input has at least one digit.
        SRAX    9
        NUM     
9H      JMP     *               Return to caller.

* Main entry point
MAIN    OUT     NAMEMSG(TERM)
        IN      NAME(TERM)
        LDA     NAME            Use first five letters of player's name
        JANZ    1F                  as seed for RAND, unless zero.
        JMP     BADIN
1H      STA     XRAND
        JMP     STRLEN          rI2 <- length of NAME
        NOP     NAME
        ST2     TEMP
1H      JMP     RANDM           Call RANDM once for every letter in
        DEC2    1                   player's name.
        J2P     1B
        OUT     SIZEMSG(TERM)   Ask user for dimension size.
        JMP     GETNUM          rA <- 1-digit number from user.
        CMPA    =3=             Ensure input is between 3 and 9, inclusive.
        JL      BADIN
        CMPA    =9=
        JG      BADIN
        STA     DIM             DIM <- rA, the dimension of the board.
        JMP     PBOARD
        HLT
        END     MAIN
